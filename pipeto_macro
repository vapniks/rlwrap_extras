#! /usr/bin/perl

# Modified version of simple_macro & pipeto rlwrap filters: https://github.com/hanslub42/rlwrap/blob/master/filters/
# combined so that you can create macros or commands from piped output (e.g. for selecting sqlite columns using fzf),
# For full documentation run: rlwrap -z pipeto_macro

# Licensed under GPL 2.0 (see COPYING file).

use lib ($ENV{RLWRAP_FILTERDIR} or ".");
use RlwrapFilter;
use POSIX qw(:signal_h ceil);
use strict;
use IPC::Open2;
use Expect;

# We want any piped pager to receive SIGWINCH.
# SIGWINCH is not in POSIX, which means that POSIX.pm doesn't
# know about it. We use 'kill -l' to find it.
my @signals = split /\s+/, `kill -l`; # yuck!
for (my $signo = 1; $signals[$signo-1]; $signo++) {
  if ($signals[$signo-1] eq 'WINCH') {
    my $sigset_unblock = POSIX::SigSet->new($signo);
    unless (defined sigprocmask(SIG_UNBLOCK, $sigset_unblock)) {
      die "Could not unblock signals: $!\n";
    }
  }
}

my $filter = new RlwrapFilter;
my $name = $filter -> name;
my $fzf = "fzf";
# $pipeline & $pipesink need to be globals because of the way REPL commands are handled
my($pipeline,$pipesink,$prompt); 
my $out_chunkno = 0;
my $wait_text = "wait ...";
# Below is the argument separator for parameterised macros.
# It should be a string that is unlikely to occur in any REPL
my $argsep = ":::";
# The char used to indicate a macro name (it should be single quoted).
my $macrochar = '\$';
# Maximum amount of time to wait for a REPL command to return
my $max_timeout = 0.5;
# Name of temporary macro used internally (should not start with < or infinite looping will occur)
my $tempmacro = "__temp__";
# Try to get the correct command name
my $comm;
if ($ENV{RLWRAP_COMMAND_PID}) {
  open IN, "/proc/$ENV{RLWRAP_COMMAND_PID}/cmdline" or die "Cannot read /proc/$ENV{RLWRAP_COMMAND_PID}/cmdline: $!\n";
  $comm = <IN>;
  close IN;
  $comm =~ m"^(?:/\S*/)?([^/\s\0]+)";
  $comm = $1;
} else {
  $filter -> command_line =~ m/(\w+).*/;
  $comm = $1;
}
#print STDERR "\$comm = \"$comm\"\n";
# newline char (sqlite3 acts strangely without this fix):
my $nl = ($comm =~ /sqlite3/) ? "\r\n" : "\n";

my(%expansions, $last_raw_input);
# Macros will be saved in the last file given in the args, or the default file if there are no args.
# Store files in reverse priority order (highest priority first).
my @macro_files = ($comm && (length($comm) > 0)) ? (($ENV{RLWRAP_HOME} || "/usr/share/rlwrap") . "/${comm}_macros") : ();
my $saved_macros = $macro_files[-1];
$expansions{$saved_macros} = {};
read_macros($saved_macros);
foreach (@ARGV) {
  my $file = $_ =~ m"/" ? $_ : ($ENV{RLWRAP_HOME} || "/usr/share/rlwrap") . "/$_";
  $expansions{$file} = {};
  read_macros($file);
  unshift(@macro_files,$file);
  $saved_macros = $file;
}

# This assignment needs to be wrapped in this "if" statement in order that "rlwrap -z listing"
# works with pipeto_macros
if ($saved_macros) {
  $SIG{__DIE__} = \&save_macros;
}

$filter -> prompts_are_never_empty(1);
$filter -> help_text(help());
$filter -> input_handler(\&expand_and_record_macros); # expand macros in input
$filter -> output_handler(\&output);
$filter -> prompt_handler(\&prompt);
#$filter -> echo_handler(sub {$last_raw_input});   # but echo the raw (un-expanded) input
# hash indicating which functions to print debug messages for:
#my %debug = ('process_pipeline'=>1,'cloak_and_dagger2'=>1,'evalmacro'=>1,'expand_and_record_macros'=>1,'prompt'=>1,'output'=>1,'findmacro'=>1,'complete_macro'=>1);
#my %debug = ('expand_and_record_macros'=>1,'process_pipeline'=>1,'prompt'=>1);
my %debug = ();
$filter -> cloak_and_dagger_verbose($debug{'cloak_and_dagger2'});
$filter -> completion_handler(\&complete_macro);
$filter -> run;

# Print debug info: 1st arg is first string to print,
# 2nd arg indicates whether or not to print current value of global $pipeline variable,
# 3rd arg indicates whether or not to print current value of global $pipesink variable,
# following args are strings to print after $pipesink (one per line)
sub debug_info {
  my $name = shift(@_);
  if ($debug{$name}) {
    $filter->send_output_oob("${name}: " . shift(@_) . "${nl}");
    $filter->send_output_oob("pipeline: \"${pipeline}\"${nl}") if shift(@_);
    $filter->send_output_oob("pipesink: \"${pipesink}\"${nl}") if shift(@_);
    for (@_) {
      $filter->send_output_oob($_ . "${nl}");
    }
  }
}

# Expand and/or record macros, and also extract pipeline parts from input.
# The shell pipeline part to be processed is stored in $pipeline (a global variable), and
# the macro name or REPL command to be processed following |> or |>> is stored in $pipesink (a global variable).
# The part before any pipelines, and the part after |> or |>> are expanded recursively, whereas shell pipelines
# are not expanded at all since they may contain words that look like macros but are not (e.g. $'s in awk commands).
# If the user wants to store a shell pipeline in a macro then the whole pipeline must be stored in the macro, including
# the initial |
sub expand_and_record_macros {
  my ($unexpanded) = @_;
  my $expanded = $last_raw_input = $unexpanded;
  my $input;
  # Macro definitions must be checked by a separate regexp so that included pipelines don't get mistaken
  # for pipelines following a macro
  if ($expanded =~ s/^\s*${macrochar}(?'em'\w+(\[\[.*?\]\])?)(\(\((?'ev'.*)\)\)\s*$)\s*$/findmacro($+{em},$+{ev})/ge) {
    undef $pipeline;
    undef $pipesink;
  } else {
    $expanded =~ /^(?'i'[^\|]*)(\|(?!>)(?'pl'([^\|]|\|(?!>))*))?(?'ps'\|>>?.*)?/;
    $input = $+{i};
    my ($pl,$ps) = ($+{pl},$+{ps});
    # expand $input & $pipesink (but not $pipeline) recursively:
    if ($input =~ /${macrochar}<?\w+/) {
      # need to do substitution first to prevent infinite recursion
      $input =~ s/${macrochar}(?'im'<?\w+(\[\[.*?\]\])?)/findmacro($+{im})/ge;
      my $x = expand_and_record_macros($input);
      $input = $x . (${pipeline}? " | ${pipeline}" : " ") . (${pipesink} || "");
    }
    if (${ps} && (${ps} =~ /^\|>>(.*)/)) {
      my $x = expand_and_record_macros($1);
      $ps = " |>> ${x} " . (${pipeline}? " | ${pipeline}" : '') . (${pipesink} || '');
    }
    $expanded = $input . (${pl}? " | ${pl}" : '') . (${ps} || '');
    $expanded =~ /^(?'i2'[^\|]*)(\|(?!>)(?'pl2'([^\|]|\|(?!>))*))?(?'ps2'\|>>?.*)?/;
    ($input, $pipeline, $pipesink) = ($+{i2},$+{pl2},$+{ps2});
    debug_info('expand_and_record_macros',"input: ${input}",1,1);
    if ($input) {
      return $input;
    }
  }
  return '';
}

sub output {
  # Replace first chunk by $wait_text
  debug_info('output',"\$_: $_\nout_chunkno: $out_chunkno",1,1);
  return $pipeline ? ($out_chunkno++ == 0 ? $wait_text : "")  : $_;
}

sub prompt {
  my ($prompt) = @_;
  $out_chunkno = 0;
  if ($pipeline || $pipesink) {
    $filter->send_output_oob("\x08" x length($wait_text) . "\n");
    my $output = $filter->cumulative_output;
    debug_info('prompt',"cumulative_output: $output",1,1);
    process_pipeline($output,$prompt,1);
    undef $pipeline;
    undef $pipesink;
    $filter->send_output_oob($nl); # start prompt on new line  
  }
  return $prompt;
}

sub process_pipeline {
  my ($output,$prompt,$depth) = @_;
  local $SIG{PIPE} = 'IGNORE'; # we don't want to die if the pipeline quits
  if ($pipesink) {
    # process the shell pipeline and store results in @output2
    # TODO: if $output is empty string, then open a one-ended pipeline instead
    my @output2;
    if ($pipeline) {
      my $pid = open2(\*READER, \*WRITER, $pipeline);
      print WRITER $output;
      close WRITER;
      while (<READER>) {
	$_ =~ s/(^\s*|\s*$)//g;
	push @output2, $_;
      }
      close READER;
    } else {
      @output2 = split(/${nl}/,$output);
    }
    debug_info('process_pipeline',"A: depth = ${depth}",1,1,"output2: ",@output2);
    $pipesink =~ /^\s*(\|>>?)\s*(.*)$/;
    if (length($1) > 2) {
      my $cmd = $2;
      my $d = '%' x $depth;
      $cmd =~ s/(?<![%0-9])${d}0?${d}(?![%0-9])/@output2/g;
      foreach (keys @output2) {
	my $x = $_ + 1;
	$cmd =~ s/(?<!%)${d}${x}${d}(?!%)/$output2[$_]/g;
      }
      # remove any remaining placeholders at this depth
      $cmd =~ s/(?<!%)${d}[0-9]+${d}(?!%)//g;
      # extract any further pipelines (into $pipeline & $pipesink), and run the next command
      my $newcmd = expand_and_record_macros($cmd);
      debug_info('process_pipeline',"B: depth = ${depth}${nl}\nnewcmd= ${newcmd}",1,1);
      my $pipeout = cloak_and_dagger2($newcmd,$prompt,$max_timeout);
      # recurse on output
      if ($pipeline || $pipesink) {
	process_pipeline($pipeout,$prompt,$depth+1);
      } else {
	$filter->send_output_oob($pipeout);
      }
    } elsif ($2 =~ /^\s*(\w+)\s*$/) { 
      findmacro($1,"@output2");
    } else {
      print STDERR "Invalid pipeline!\n";
    }
  } else {
    # TODO: if $output is empty string, then call system($pipeline) instead
    open PIPELINE, "| $pipeline";
    debug_info('process_pipeline',"C: depth = $depth",1,0,"output = ${output}");
    print PIPELINE $output;
    close PIPELINE; # this waits until pipeline has finished
  }
}

# Substitute for $filter->cloak_and_dagger, which works with sqlite3
# $question = command to send to underlying REPL, $prompt = prompt string to wait for,
# $timeout = max amount of time to wait in seconds 
sub cloak_and_dagger2 {
  my ($question, $prompt, $timeout) = @_;
  $prompt ||= $filter -> last('prompt');
  open(CMD_IN_OUT, "+<&" . $ENV{RLWRAP_MASTER_PTY_FD}) or die "Can't dup rlwrap file descriptor: $!";
  my $exp = Expect->exp_init(\*CMD_IN_OUT);
  #$exp->debug(2);
  debug_info('cloak_and_dagger2',"question: $question");
  $exp->send("$question${nl}");
  my ($pos,$err,$match,$before,$after) = $exp->expect(ceil($timeout),'-re',$prompt);
  debug_info('cloak_and_dagger2',"error: $err");
  debug_info('cloak_and_dagger2',"response: $before");
  debug_info('cloak_and_dagger2',"after: $after");
  close(CMD_IN_OUT);
  $before =~ s/^.*${nl}//;
  return $before;
}

sub evalmacro {
  my ($val) = @_;
  #my $prompt = $filter -> last('prompt'); #TODO
  my $prompt = "[[:alnum:]]+>\s*";
  debug_info('evalmacro',"val: $val");
  $val =~ /^\s*(?'r'[^\|\s][^|]*)?(?'s'\|.*)?/; 
  my ($r,$s) = ($+{r},$+{s}); # ${r} = REPL command, ${s} = shell pipeline
  # alter the pipeline so that it stores its output in $tempmacro,
  # and split it into $val2, $pipeline & $pipesink (global variables)
  my $val2 = expand_and_record_macros((${r}||'') . (${s}||'') . " |> ${tempmacro}");
  debug_info('evalmacro',"val2: $val2",1,1);
  # evaluate the first part of the pipeline if necessary
  my $pl = (length(${val2}) > 0 ? cloak_and_dagger2($val2,$prompt,$max_timeout) : '');
  debug_info('evalmacro',"pl: $pl",1,1);
  # Feed $pl into $pipeline & $pipesink, which should store the results into $tempmacro, and return this
  process_pipeline($pl,$prompt,1);
  return findmacro($tempmacro);
}

sub findmacro {
  my($macro,$expansion) = @_;
  my ($eval, $args);
  $macro =~ /(?'e'<)?(?'m'\w+)(\[\[(?'a'.*?)\]\])?/;
  ($eval, $macro, $args) = ($+{e}, $+{m}, $+{a});
  debug_info('findmacro',"macro: $macro\neval: $eval\nargs: $args\nexpansion: $expansion");
  if ($expansion) {
    if ($expansion eq " ") {
      delete ${$expansions{$macro_files[0]}}{$macro};
    } else {
      return ${$expansions{$macro_files[0]}}{$macro} = $expansion;
    }
  } else {
    foreach (@macro_files) {
      my $val = ${$expansions{$_}}{$macro};
      if ($val) {
	if ($args) {
	  my $i = 1;
	  foreach (split(/${argsep}/,$args)) {
	    # TODO: macroexpand args? could cause problems if they contain pipes, but would be very convenient
	    $val =~ s/${macrochar}${i}/$_/g;
	    $i += 1;
	  }
	}
	debug_info('findmacro',"val: $val");
	return $eval ? evalmacro($val) : $val;
      }
    }
  }
  return "";
}

sub safe_backtick {
    my @command_line = @_;
    my $command_line = join ' ', @command_line;
    open my $pipefh, '-|' or exec @command_line or die "$command_line failed: $!\n";
    my $result;
    { local $/;               # slurp all output in one go
      $result = <$pipefh>; 
      close $pipefh;
    }
    chomp $result;            # chop off last newline
    return $result
}

sub complete_macro {
  my($line, $prefix, @completions) = @_;
  debug_info('complete_macro',"prefix: $prefix");
  if ($prefix =~ /^${macrochar}(?'e'<)?(?'m'\w*)$/) { # completing a macro with no args
    my $eval = $+{e};
    my $query = length($+{m}) > 0 ? "--query '^$+{m}'" : "";
    my @items;
    my %seen;
    foreach (@macro_files) {
      my $file = $_;
      foreach (keys %{$expansions{$file}}) {
	if (!$seen{$_}) {
	  push(@items,$_ . " " . ${$expansions{$file}}{$_});
	  $seen{$_} = 1;
	}
      }
    }
    # Need to make fzf full screen otherwise prompt disappears when it returns
    my $pid = open2(\*READER, \*WRITER, "$fzf -1 +m $query --height=100%|cut -d' ' -f2-");
    local $\ = "\n";
    foreach (@items) { print WRITER $_; }
    close WRITER;
    my $expansion = <READER>;
    close READER;
    chomp($expansion);
    debug_info('complete_macro',"expansion: $expansion");
    # if $expansion begins with |< or |<< then run the pipeline to get the completion
    if ($eval) {
      $expansion = evalmacro($expansion);      
    }
    chomp($expansion);
    unshift @completions, $expansion if $expansion;
  } elsif ($prefix =~ /^${macrochar}(<?\w*\[\[.*?\]\])$/) { # completing a macro with args
    my $expansion = findmacro($1);
    unshift @completions, $expansion if $expansion;
  }
  return @completions;
}

sub read_macros {
  return unless @_;
  my ($file) = @_;
  if (-f $file) {
    -w $file or die "$saved_macros exists but is not writable!\n";
    open MACROS, $file or die  "$saved_macros exists but is not readable!\n";
    while(<MACROS>) {
      chomp;
      my($macro, $expansion) = /(\S+)\s+(.*)/;
      $expansions{$file} -> {$macro} = $expansion;
    }
    close MACROS;
  }
}

sub save_macros {
  return unless $saved_macros;
  open MACROS, ">$saved_macros" or die "cannot write to $saved_macros: $!\n"; # this error may be lost
  foreach my $macro (sort keys %{$expansions{$saved_macros}}) {
    print MACROS "$macro ${$expansions{$saved_macros}}{$macro}\n";
  }
  close MACROS;
}

sub help {
  return <<EOF;
Usage: rlwrap -z '$name [<FILE>...]' <COMMAND>
Parameterised macro processing, and pipelines for building REPL commands or macros from shell output.
NOTE: you may need to call rlwrap with -b '' to prevent '\$' being interpreted as a word break.

MACROS

Syntax:
 \$foo       : Use a macro - \$foo will be replaced by its definition when command is entered.
 \$foo<TAB>  : Expand it right now - \$foo will be replaced by its definition immediately.
 \$f<TAB>    : Select a macro using fzf - selection will be limited to macros whose names start with f.
 \$foo((ex pan sion))<ENTER> 
            : (re-)define \$foo to "ex pan sion".
 \$foo(( ))<ENTER> 
            : Delete \$foo (there must be 1 space between the opening & closing parentheses).
 \$<foo<TAB> : Expand & evaluate \$foo, and immediately place results on command line.
              If you use this kind of macro normally without TAB completion then it will be 
              expanded & evaluated when the entire command line is entered, but before the line
              is send to the REPL interpreter. See below for some examples.

Macros are kept between sessions in \$RLWRAP_HOME/<COMMAND>_macros if no <FILE> argument
is supplied, or the last <FILE> argument if there are any.
The file arguments are processed in order, and macros in later files get priority over
those in earlier files. If a file argument contains a / char then it is assumed to be a full
path to the file, otherwise the file is assumed to be in \$RLWRAP_HOME or /usr/share/rlwrap
if \$RLWRAP_HOME is unset.
Only the macros in the last <FILE> (or \$RLWRAP_HOME/<COMMAND>) may be altered or deleted.

PIPELINES

Syntax:
  <REPL CMD> | <SHELL CMD>     : Pipe output from REPL command into STDIN of shell command.
 <SHELL CMD> |> \$foo           : Save output from shell command into macro \$foo.
 <SHELL CMD> |>> <REPL CMD> %% : Insert output from shell command into position marked by %%,
                                 and then execute REPL command. To insert the Nth line of
                                 output use \%N% (e.g. to insert 5th & 6th lines: <CMD> %5% %6%).

The | & |>> pipeline operators can be chained together to form alternating sequences of REPL & shell commands.
In this case the Nth output from the Mth |>> operator is referenced by using M %'s either side of the number N, 
e.g. %%%2%%% for the 2nd line of output from the 3rd |>> operator. If N is 0, or there is no number between
the %'s, then the entire output is inserted.
You can use output from previous |>> operators after the most recent one, e.g. in this example <CMD3> is called 
with the 5th line of output from <SHELL CMD1>, and the 1st line of output from <SHELL CMD2>:

  <CMD1> | <SHELL CMD1> |>> <CMD2> | <SHELL CMD2> |>> <CMD3> %5% %%1%%

You can use pipeline operators in macros, however when a pipeline is processed macro expansion will only occur
in the sections containing REPL commands, not the sections containing shell commands. This is so that \$'s can
be used for other purposes by shell commands, e.g. awk variables.

EXAMPLES

Browse sqlite3 table names with less:               sqlite> .tables|less
Export them to a file:                              sqlite> .tables|cat > tables.txt
View contents of the current directory:             sqlite> |ls
Create a macro for selecting a table using fzf:     sqlite> \$choosetbl((.tables|fzf))
Build a SELECT statement using the macro:           sqlite> SELECT * FROM \$<choosetbl;
Select a command using fzf and view its usage       sqlite> .help | fzf | awk '{print $1}' |>> .help %% | less

Here's a more complex example (split over 2 lines) involving pipeline operators. fzf is used to first choose a table, 
and then select some columns from that table. Finally these strings are used to build a SELECT statement which is 
passed to the REPL:

sqlite> .tables|fzf |>> .schema %% |grep "CREATE TABLE"|sed -e 's/[^()]*(\(.*\))/\\1/g' -e 's/,\s*/\\r\\n/g'\\
 |fzf|awk 'BEGIN{x=""}{x=(!x)?$1:x","$1}END{print x}'|>> SELECT %%%% FROM %% LIMIT 5;

(note: you could store this whole pipeline, or part of it, in another macro).

Notes: 
 - You may need to redirect STDOUT to STDERR using ">&2" to get some shell commands such as "less" to work in 
   pipelines that pipe their output to a REPL command. 
 - If you use fzf in a pipeline set "--height=100%" in the options to avoid messing up the prompt when it returns.
EOF
}
